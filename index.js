import * as THREE from "three";
import { Tween, Ease } from "@createjs/tweenjs";
const OrbitControls = require("three-orbit-controls")(THREE);

// The number of spheres to render.
const spheres = 89;

// Maximum value of the dot product between two vectors (same vector: 1.0, opposite vectors: -1.0)
// acceptable to connect to vertices in the line generation algorithm.
const maxDotValue = 0.8;

// Maximum number of tries the line generation algorithm uses to find a good candidate to connect
// the current vertex with.
const maxTries = 100;

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color("white");

// Camera setup
const wh = window.innerWidth / window.innerHeight;
const camera = new THREE.PerspectiveCamera(45, wh, 1, 8000);
camera.position.set(0, 0, -4);

/**
 * Line setup
 * Three.js ShaderMaterials allow you to configure custom materials that execute
 * WebGL vertex and fragment shaders.
 *
 * A shader is a massively-parallel program run by the GPU. There are multiple types of shaders,
 * but the most common pipeline (specially on the web) are just vertex and fragment shaders.
 *
 * A vertex shader is executed on every vertex of a GPU primitive (points, lines, triangles, etc.).
 * Usually is in charge to transforming position coordinates (gl_Position) between projection spaces
 * (model -> world -> camera -> screen -> device) and any other kind of processing needed by any other
 * attribute (texture coordinates, normal vectors, colors, etc.).
 *
 * A fragment shader is executed on every fragment (pixel) generated by the rasterized primitives.
 * It usually takes care of doing all the computation needed to display the final color of the fragment (gl_FragColor),
 * which can range from complex light models to simple texture sampling.
 *
 * In both vertex and fragment shaders, we will find the following types of variables:
 * - attribute: Vertex attribute data (vertex-shader only). Describe the data that composes a vertex
 * and is the input to the vertex shader. They are different for each vertex and are read from the vertex
 * buffer (using the index buffer).
 * - varying: Vertex-Shader-defined data. Each vertex shader can store data to pass down to the fragment shader in these
 * kind of variables. A fragment shader's varying variables will contain the result of interpolating the values
 * stored by all vertices that composed the rasterized primitive (i.e. the three vertices forming a triangle primitive).
 * - uniform: Global variables which value is uniform for all vertex/fragment shader invocations. Are usually used to
 * pass state information to drive the computations happening on this shaders (i.e. projection matrices, time, resolution, etc.)
 */
const lineMaterial = new THREE.ShaderMaterial({
  uniforms: {
    t: new THREE.Uniform(0.0)
  },
  vertexShader: `
// Vertex attribute describing the relative position of a vertex inside a line.
attribute float linePosition;
// Varying variable needed to pass linePosition to the fragment shader.
varying float vLinePosition;
void main() {
  // Store the vertex attribute into the varying variable.
  vLinePosition = linePosition;
  // Transform the model position coordinates to screen coordinates.
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`,
  fragmentShader: `
// Uniform describing how far along the line we should render.
uniform float t;
varying float vLinePosition;
void main() {
  // Calculate the fragment's opacity based on the varying vLinePosition and t uniform.
  float opacity = ceil(t - vLinePosition);
  // Output black with the computed opacity.
  gl_FragColor = vec4(0.0, 0.0, 0.0, vLinePosition * opacity);
}
`,
  transparent: true,
  depthWrite: false
});

// Renderer setup
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);

const app = document.getElementById("app");
app.appendChild(renderer.domElement);

// Camera controls setup
const cameraControls = new OrbitControls(camera, renderer.domElement);
cameraControls.target.set(0, 0, 0);

/**
 * Utility to calculate the position of a given number of spheres.
 *
 * @param {int} samples number of spheres to create
 * @param {bool} randomize whether the order should be randomized or uniform
 */
const fibonacciSphere = (samples, randomize) => {
  var rnd = 1;
  if (randomize) {
    rnd = Math.random * samples;
  }
  var coords = [];
  var offset = 2 / samples;
  var increment = Math.PI * (3 - Math.sqrt(5));

  for (let i = 1; i < samples; i++) {
    let y = i * offset - 1 + offset / 2;
    let r = Math.sqrt(1 - Math.pow(y, 2));
    let phi = ((i + rnd) % samples) * increment;
    let x = Math.cos(phi) * r;
    let z = Math.sin(phi) * r;
    coords.push([x, y, z]);
  }
  return coords;
};

/**
 * Utiliy for constructing a THREE sphere.
 *
 * @param {int} radius desired radius of the sphere
 * @param {string} c desired color of the sphere
 */
const createSphere = (radius = 0.1, c = "white") => {
  const material = new THREE.MeshBasicMaterial({ color: c });
  const geometry = new THREE.SphereGeometry(radius, 16, 8);
  const sphere = new THREE.Mesh(geometry, material);
  return sphere;
};

/**
 * Tween animation
 * - attaches to the group of spheres in order to change it's scale.
 *
 * @param {THREE.Object3D}  ball
 */
const changeBallScale = ball => {
  new Tween(ball.scale)
    .to({ x: 0.01, y: 0.01, z: 0.01 })
    .wait(1000)
    .to({ x: 1.0, y: 1.0, z: 1.0 }, 1000, Ease.backOut)
    .wait(15000)
    .to({ x: 0, y: 0, z: 0 }, 1000, Ease.backIn);
};

/**
 * Tween animation
 * - attaches to each individual sphere to change their scale.
 *
 * @param {THREE.Object3D} point
 * @param {int} index
 */
const changeScale = (point, index) => {
  new Tween(point.scale)
    .to(
      {
        x: point.scale.x,
        y: point.scale.y,
        z: point.scale.z
      },
      5000,
      Ease.elasticIn
    )
    .wait(index * 15)
    .to(
      {
        x: point.scale.x * 2,
        y: point.scale.y * 2,
        z: point.scale.z * 2
      },
      150,
      Ease.elasticOut
    )
    .to(
      {
        x: point.scale.x,
        y: point.scale.y,
        z: point.scale.z
      },
      100,
      Ease.elasticIn
    )
    .wait(5000)
    .to(
      {
        x: point.scale.x * 2,
        y: point.scale.y * 2,
        z: point.scale.z * 2
      },
      150,
      Ease.elasticOut
    )
    .to(
      {
        x: point.scale.x,
        y: point.scale.y,
        z: point.scale.z
      },
      100,
      Ease.elasticIn
    );
};

/**
 * Tween animation
 * - attaches to the line material in order to change its opacity.
 *
 * @param {THREE.ShaderMaterial} material
 */
const changeLineOpacity = material => {
  new Tween(material.uniforms.t).wait(7000).to(
    {
      value: 1.0
    },
    1000,
    Ease.cubicIn
  );
};

// Group to contain individual spheres.
const ball = new THREE.Group();
ball.rotation.set(10, 0, 0); // initial rotation position

/**
 * Called manually just before render();
 */
const fillScene = () => {
  const fibonacciSpherePoints = fibonacciSphere(spheres, false);
  const positions = [];
  fibonacciSpherePoints.forEach((coords, index, array) => {
    const point = createSphere(0.03, "black");

    point.position.set(...coords);
    // attach Tween animations to each sphere
    changeScale(point, index);

    // store the position to later use on line geometry creation
    positions.push(coords);

    // add it to the group
    ball.add(point);
  });

  // construct the line geometry
  // points are added to the line randomly until all vertices have been visited.
  const positionArray = [];
  const linePositionArray = [];

  let nTries = 0;
  let lineIndex = 0;
  const currentPos = new THREE.Vector3().fromArray(positions.pop());
  const nextPos = new THREE.Vector3();
  while (positions.length > 0) {
    // add a line segment between two fibonacci points to the line array
    nextPos.fromArray(
      positions.splice(Math.floor(Math.random() * (positions.length - 1)), 1)[0]
    );

    // discard points that are not close enough to each other on the sphere's surface
    if (currentPos.dot(nextPos) < maxDotValue && nTries < maxTries) {
      positions.push(nextPos.toArray());
      nTries++;
    }
    // add line if vertices are valid
    else {
      positionArray.push(...currentPos.toArray(), ...nextPos.toArray());

      // add relative position in line to drive the line opacity animation
      linePositionArray.push(
        lineIndex / (fibonacciSpherePoints.length - 1),
        (lineIndex + 1) / (fibonacciSpherePoints.length - 1)
      );

      // advance the line generation algorithm
      nTries = 0;
      ++lineIndex;
      currentPos.copy(nextPos);
    }
  }
  console.log(linePositionArray.length / 2, fibonacciSpherePoints.length);

  // create the line mesh
  const lineGeometry = new THREE.BufferGeometry();
  lineGeometry.addAttribute(
    "position",
    new THREE.BufferAttribute(new Float32Array(positionArray), 3)
  );
  lineGeometry.addAttribute(
    "linePosition",
    new THREE.BufferAttribute(new Float32Array(linePositionArray), 1)
  );
  const lineMesh = new THREE.LineSegments(lineGeometry, lineMaterial);

  // attach a Tween animation to modify the line opacity
  changeLineOpacity(lineMaterial);

  // add the line to the group
  ball.add(lineMesh);

  // add the group of spheres and lines to the scene
  scene.add(ball);

  // attach a Tween animation to the group to scale it out of sight
  changeBallScale(ball);
};

/**
 * THREE animation
 * - rotates the overall group of spheres.
 */
const animate = () => {
  ball.rotation.x -= 0.005;
  ball.rotation.y -= 0.005;
};

/**
 * Render function, called manually at the end.
 */
const render = () => {
  // Internal THREE function that handles native animation (not Tween)
  requestAnimationFrame(render);
  animate();
  renderer.render(scene, camera);
};

fillScene();
render();
